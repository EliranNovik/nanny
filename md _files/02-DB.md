# Database (Supabase Postgres) for Nanny MVP

You will create SQL files and upload them to Supabase SQL editor.

Run order:

1. 001_init.sql
2. 002_rls.sql
3. 003_policies.sql

## Tables overview

Auth:

- Supabase auth.users is the source of truth for identity.

App tables:

1. profiles
2. freelancer_profiles
3. job_requests
4. job_candidate_notifications
5. job_confirmations
6. conversations
7. messages

### Key concepts

- "Client" creates job_requests
- Backend generates candidate notifications into job_candidate_notifications
- Freelancer confirms availability => job_confirmations
- Client selects one freelancer => job_requests.status becomes "locked"
- conversation created for the job, messages are realtime

## Status enums

job_requests.status:

- draft
- ready
- notifying
- confirmations_closed
- locked
- active
- completed
- cancelled

job_candidate_notifications.status:

- pending
- opened
- expired
- withdrawn
- selected
- closed

job_confirmations.status:

- available
- declined
- expired

---

## 001_init.sql (create tables, types, indexes)

Create a file db/sql/001_init.sql with the following:

````sql
-- 001_init.sql

create extension if not exists "pgcrypto";

-- Role type for profiles
do $$ begin
  create type public.user_role as enum ('client', 'freelancer');
exception when duplicate_object then null;
end $$;

-- Job status
do $$ begin
  create type public.job_status as enum (
    'draft','ready','notifying','confirmations_closed','locked','active','completed','cancelled'
  );
exception when duplicate_object then null;
end $$;

-- Notification status
do $$ begin
  create type public.notification_status as enum (
    'pending','opened','expired','withdrawn','selected','closed'
  );
exception when duplicate_object then null;
end $$;

-- Confirmation status
do $$ begin
  create type public.confirmation_status as enum (
    'available','declined','expired'
  );
exception when duplicate_object then null;
end $$;

-- Profiles (1:1 with auth.users)
create table if not exists public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  role public.user_role not null,
  full_name text,
  phone text,
  photo_url text,
  city text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

-- Freelancer-specific profile fields
create table if not exists public.freelancer_profiles (
  user_id uuid primary key references public.profiles(id) on delete cascade,
  bio text,
  languages text[] not null default '{}',
  has_first_aid boolean not null default false,
  newborn_experience boolean not null default false,
  special_needs_experience boolean not null default false,
  max_children int not null default 2,
  hourly_rate_min int,
  hourly_rate_max int,
  available_now boolean not null default false,
  availability_note text,
  rating_avg numeric(3,2) not null default 0,
  rating_count int not null default 0,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

-- Job requests
create table if not exists public.job_requests (
  id uuid primary key default gen_random_uuid(),
  client_id uuid not null references public.profiles(id) on delete cascade,
  status public.job_status not null default 'draft',

  -- Core structured answers
  care_type text not null,                 -- e.g. "full_time", "part_time", "occasional"
  children_count int not null,
  children_age_group text not null,        -- e.g. "newborn", "infant", "toddler", "mixed"
  location_city text not null,
  location_lat numeric,
  location_lng numeric,

  start_at timestamptz,
  shift_hours text,                        -- "up_to_4", "4_8", "full_day", "night"
  languages_pref text[] not null default '{}',
  requirements text[] not null default '{}', -- e.g. ["first_aid","special_needs"]
  budget_min int,
  budget_max int,

  notes text,

  -- Confirmation window
  confirm_window_seconds int not null default 90,
  confirm_starts_at timestamptz,
  confirm_ends_at timestamptz,

  -- Final selection
  selected_freelancer_id uuid references public.profiles(id),
  locked_at timestamptz,

  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

create index if not exists idx_job_requests_client_id on public.job_requests(client_id);
create index if not exists idx_job_requests_status on public.job_requests(status);

-- Candidate notifications (sent to freelancers)
create table if not exists public.job_candidate_notifications (
  id uuid primary key default gen_random_uuid(),
  job_id uuid not null references public.job_requests(id) on delete cascade,
  freelancer_id uuid not null references public.profiles(id) on delete cascade,
  status public.notification_status not null default 'pending',
  created_at timestamptz not null default now(),
  opened_at timestamptz,
  closed_at timestamptz,
  unique(job_id, freelancer_id)
);

create index if not exists idx_candidate_job on public.job_candidate_notifications(job_id);
create index if not exists idx_candidate_freelancer on public.job_candidate_notifications(freelancer_id);

-- Availability confirmations
create table if not exists public.job_confirmations (
  id uuid primary key default gen_random_uuid(),
  job_id uuid not null references public.job_requests(id) on delete cascade,
  freelancer_id uuid not null references public.profiles(id) on delete cascade,
  status public.confirmation_status not null,
  created_at timestamptz not null default now(),
  unique(job_id, freelancer_id)
);

create index if not exists idx_confirm_job on public.job_confirmations(job_id);

-- Conversations per job
create table if not exists public.conversations (
  id uuid primary key default gen_random_uuid(),
  job_id uuid unique not null references public.job_requests(id) on delete cascade,
  client_id uuid not null references public.profiles(id) on delete cascade,
  freelancer_id uuid not null references public.profiles(id) on delete cascade,
  created_at timestamptz not null default now()
);

-- Messages
create table if not exists public.messages (
  id uuid primary key default gen_random_uuid(),
  conversation_id uuid not null references public.conversations(id) on delete cascade,
  sender_id uuid not null references public.profiles(id) on delete cascade,
  body text not null,
  created_at timestamptz not null default now()
);

create index if not exists idx_messages_conversation on public.messages(conversation_id);
create index if not exists idx_messages_created_at on public.messages(created_at);

-- updated_at trigger helper
create or replace function public.set_updated_at()
returns trigger language plpgsql as $$
begin
  new.updated_at = now();
  return new;
end $$;

do $$ begin
  create trigger profiles_set_updated_at
  before update on public.profiles
  for each row execute function public.set_updated_at();
exception when duplicate_object then null;
end $$;

do $$ begin
  create trigger freelancer_profiles_set_updated_at
  before update on public.freelancer_profiles
  for each row execute function public.set_updated_at();
exception when duplicate_object then null;
end $$;

do $$ begin
  create trigger job_requests_set_updated_at
  before update on public.job_requests
  for each row execute function public.set_updated_at();
exception when duplicate_object then null;
end $$;


-- 002_rls.sql
alter table public.profiles enable row level security;
alter table public.freelancer_profiles enable row level security;
alter table public.job_requests enable row level security;
alter table public.job_candidate_notifications enable row level security;
alter table public.job_confirmations enable row level security;
alter table public.conversations enable row level security;
alter table public.messages enable row level security;


-- 003_policies.sql

-- PROFILES
create policy "profiles_select_own"
on public.profiles for select
using (auth.uid() = id);

create policy "profiles_update_own"
on public.profiles for update
using (auth.uid() = id);

create policy "profiles_insert_own"
on public.profiles for insert
with check (auth.uid() = id);

-- FREELANCER PROFILES
create policy "freelancer_select_public"
on public.freelancer_profiles for select
using (true);

create policy "freelancer_upsert_own"
on public.freelancer_profiles for insert
with check (auth.uid() = user_id);

create policy "freelancer_update_own"
on public.freelancer_profiles for update
using (auth.uid() = user_id);

-- JOB REQUESTS
create policy "job_requests_select_own_client_or_selected_freelancer"
on public.job_requests for select
using (
  auth.uid() = client_id
  or auth.uid() = selected_freelancer_id
);

create policy "job_requests_insert_client_only"
on public.job_requests for insert
with check (auth.uid() = client_id);

create policy "job_requests_update_client_only"
on public.job_requests for update
using (auth.uid() = client_id);

-- CANDIDATE NOTIFICATIONS
create policy "candidate_notifications_select_own"
on public.job_candidate_notifications for select
using (auth.uid() = freelancer_id);

create policy "candidate_notifications_update_own"
on public.job_candidate_notifications for update
using (auth.uid() = freelancer_id);

-- CONFIRMATIONS
create policy "confirmations_select_own_or_client"
on public.job_confirmations for select
using (
  auth.uid() = freelancer_id
  or auth.uid() in (select client_id from public.job_requests where id = job_id)
);

create policy "confirmations_insert_freelancer"
on public.job_confirmations for insert
with check (auth.uid() = freelancer_id);

create policy "confirmations_update_freelancer"
on public.job_confirmations for update
using (auth.uid() = freelancer_id);

-- CONVERSATIONS
create policy "conversations_select_participants"
on public.conversations for select
using (auth.uid() = client_id or auth.uid() = freelancer_id);

-- MESSAGES
create policy "messages_select_participants"
on public.messages for select
using (
  auth.uid() in (
    select client_id from public.conversations c where c.id = conversation_id
    union
    select freelancer_id from public.conversations c where c.id = conversation_id
  )
);

create policy "messages_insert_participants"
on public.messages for insert
with check (
  auth.uid() in (
    select client_id from public.conversations c where c.id = conversation_id
    union
    select freelancer_id from public.conversations c where c.id = conversation_id
  )
);



---

# 03-BACKEND.md

```md
# Backend (Node.js + Express + TypeScript) MVP

Backend responsibilities (trusted):
- Create job request and set it to "ready"
- Find matching freelancers
- Create candidate notifications records
- Open confirmation window (set confirm_starts_at/ends_at, status=notifying)
- Close window and mark expired notifications
- Lock job to selected freelancer
- Create conversation row (job chat)

## Setup
From apps/api:

```bash
npm init -y
npm i express cors dotenv zod @supabase/supabase-js
npm i -D typescript ts-node-dev @types/express @types/cors @types/node
npx tsc --init


import { createClient } from "@supabase/supabase-js";

const url = process.env.SUPABASE_URL!;
const serviceKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;

export const supabaseAdmin = createClient(url, serviceKey, {
  auth: { persistSession: false }
});




import { Request, Response, NextFunction } from "express";
import { createClient } from "@supabase/supabase-js";

const supa = createClient(
  process.env.SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!,
  { auth: { persistSession: false } }
);

export async function requireUser(req: Request, res: Response, next: NextFunction) {
  const authHeader = req.headers.authorization || "";
  const token = authHeader.startsWith("Bearer ") ? authHeader.slice(7) : null;
  if (!token) return res.status(401).json({ error: "Missing bearer token" });

  const { data, error } = await supa.auth.getUser(token);
  if (error || !data?.user) return res.status(401).json({ error: "Invalid token" });

  (req as any).user = data.user;
  next();
}



import { supabaseAdmin } from "../supabase";

type Job = {
  id: string;
  children_count: number;
  children_age_group: string;
  location_city: string;
  budget_min: number | null;
  budget_max: number | null;
  requirements: string[];
  languages_pref: string[];
};

export async function findCandidates(job: Job, limit = 30) {
  // Pull freelancers in same city that are available_now and meet requirements.
  // For MVP, city match only. Later add geo radius.
  let q = supabaseAdmin
    .from("profiles")
    .select("id, city, role, freelancer_profiles!inner(*)")
    .eq("role", "freelancer")
    .eq("city", job.location_city)
    .eq("freelancer_profiles.available_now", true);

  const { data, error } = await q.limit(limit);
  if (error) throw error;

  // Filter in code for requirements and budget.
  const candidates = (data || []).filter((row: any) => {
    const fp = row.freelancer_profiles;
    if (!fp) return false;

    if (job.children_count > fp.max_children) return false;

    if (job.requirements?.includes("first_aid") && !fp.has_first_aid) return false;
    if (job.requirements?.includes("newborn") && !fp.newborn_experience) return false;
    if (job.requirements?.includes("special_needs") && !fp.special_needs_experience) return false;

    if (job.budget_min != null && fp.hourly_rate_max != null && fp.hourly_rate_max < job.budget_min) return false;
    if (job.budget_max != null && fp.hourly_rate_min != null && fp.hourly_rate_min > job.budget_max) return false;

    if (job.languages_pref?.length) {
      const ok = job.languages_pref.some((l) => (fp.languages || []).includes(l));
      if (!ok) return false;
    }

    return true;
  });

  return candidates.map((c: any) => c.id);
}


import { Router } from "express";
import { z } from "zod";
import { supabaseAdmin } from "../supabase";
import { findCandidates } from "../logic/match";

export const jobsRouter = Router();

const CreateJobSchema = z.object({
  care_type: z.string(),
  children_count: z.number().int().min(1),
  children_age_group: z.string(),
  location_city: z.string(),
  start_at: z.string().datetime().optional(),
  shift_hours: z.string().optional(),
  languages_pref: z.array(z.string()).default([]),
  requirements: z.array(z.string()).default([]),
  budget_min: z.number().int().optional().nullable(),
  budget_max: z.number().int().optional().nullable(),
  notes: z.string().optional().nullable(),
  confirm_window_seconds: z.number().int().min(30).max(180).default(90)
});

// Create job and start notifying immediately (job_ready threshold assumed met)
jobsRouter.post("/", async (req, res) => {
  const user = (req as any).user;
  const parsed = CreateJobSchema.safeParse(req.body);
  if (!parsed.success) return res.status(400).json(parsed.error);

  const payload = parsed.data;

  const { data: job, error: jobErr } = await supabaseAdmin
    .from("job_requests")
    .insert({
      client_id: user.id,
      status: "ready",
      ...payload,
      start_at: payload.start_at ? new Date(payload.start_at).toISOString() : null
    })
    .select("*")
    .single();

  if (jobErr) return res.status(500).json({ error: jobErr.message });

  // Candidates
  const candidates = await findCandidates(job, 30);

  // Create notifications
  if (candidates.length) {
    const rows = candidates.map((fid) => ({ job_id: job.id, freelancer_id: fid, status: "pending" }));
    await supabaseAdmin.from("job_candidate_notifications").insert(rows);
  }

  // Open confirm window
  const starts = new Date();
  const ends = new Date(starts.getTime() + (job.confirm_window_seconds || 90) * 1000);

  await supabaseAdmin
    .from("job_requests")
    .update({
      status: "notifying",
      confirm_starts_at: starts.toISOString(),
      confirm_ends_at: ends.toISOString()
    })
    .eq("id", job.id);

  return res.json({ job_id: job.id, confirm_ends_at: ends.toISOString() });
});

// Freelancer "open" notification
jobsRouter.post("/:jobId/notifications/:notifId/open", async (req, res) => {
  const user = (req as any).user;
  const { notifId } = req.params;

  const { error } = await supabaseAdmin
    .from("job_candidate_notifications")
    .update({ status: "opened", opened_at: new Date().toISOString() })
    .eq("id", notifId)
    .eq("freelancer_id", user.id);

  if (error) return res.status(500).json({ error: error.message });
  res.json({ ok: true });
});

// Freelancer confirm availability
jobsRouter.post("/:jobId/confirm", async (req, res) => {
  const user = (req as any).user;
  const { jobId } = req.params;

  // Ensure still in window
  const { data: job } = await supabaseAdmin.from("job_requests").select("*").eq("id", jobId).single();
  if (!job) return res.status(404).json({ error: "Job not found" });

  const now = new Date();
  if (!job.confirm_ends_at || now > new Date(job.confirm_ends_at)) {
    return res.status(400).json({ error: "Confirmation window ended" });
  }

  // Insert confirmation
  const { error } = await supabaseAdmin
    .from("job_confirmations")
    .upsert({ job_id: jobId, freelancer_id: user.id, status: "available" });

  if (error) return res.status(500).json({ error: error.message });

  res.json({ ok: true });
});

// Client fetch confirmed candidates after window
jobsRouter.get("/:jobId/confirmed", async (req, res) => {
  const user = (req as any).user;
  const { jobId } = req.params;

  const { data: job } = await supabaseAdmin.from("job_requests").select("*").eq("id", jobId).single();
  if (!job || job.client_id !== user.id) return res.status(404).json({ error: "Not found" });

  const { data: confs, error } = await supabaseAdmin
    .from("job_confirmations")
    .select("freelancer_id")
    .eq("job_id", jobId)
    .eq("status", "available");

  if (error) return res.status(500).json({ error: error.message });

  const ids = (confs || []).map((c) => c.freelancer_id);

  // Pull profile data for cards
  const { data: profiles, error: pErr } = await supabaseAdmin
    .from("profiles")
    .select("id, full_name, photo_url, city, freelancer_profiles(*)")
    .in("id", ids);

  if (pErr) return res.status(500).json({ error: pErr.message });

  res.json({ freelancers: profiles || [] });
});

// Client selects freelancer and locks job + creates conversation
jobsRouter.post("/:jobId/select", async (req, res) => {
  const user = (req as any).user;
  const { jobId } = req.params;
  const schema = z.object({ freelancer_id: z.string().uuid() });
  const parsed = schema.safeParse(req.body);
  if (!parsed.success) return res.status(400).json(parsed.error);

  const { freelancer_id } = parsed.data;

  const { data: job } = await supabaseAdmin.from("job_requests").select("*").eq("id", jobId).single();
  if (!job || job.client_id !== user.id) return res.status(404).json({ error: "Not found" });

  // Lock
  const { error: lockErr } = await supabaseAdmin
    .from("job_requests")
    .update({
      status: "locked",
      selected_freelancer_id: freelancer_id,
      locked_at: new Date().toISOString()
    })
    .eq("id", jobId);

  if (lockErr) return res.status(500).json({ error: lockErr.message });

  // Close notifications
  await supabaseAdmin
    .from("job_candidate_notifications")
    .update({ status: "closed", closed_at: new Date().toISOString() })
    .eq("job_id", jobId);

  // Mark selected
  await supabaseAdmin
    .from("job_candidate_notifications")
    .update({ status: "selected", closed_at: new Date().toISOString() })
    .eq("job_id", jobId)
    .eq("freelancer_id", freelancer_id);

  // Create conversation
  const { data: convo, error: convoErr } = await supabaseAdmin
    .from("conversations")
    .insert({
      job_id: jobId,
      client_id: user.id,
      freelancer_id
    })
    .select("*")
    .single();

  if (convoErr) return res.status(500).json({ error: convoErr.message });

  res.json({ conversation_id: convo.id });
});




import express from "express";
import cors from "cors";
import "dotenv/config";
import { requireUser } from "./middleware/auth";
import { jobsRouter } from "./routes/jobs";

const app = express();
app.use(cors({ origin: process.env.CORS_ORIGIN, credentials: true }));
app.use(express.json());

app.get("/health", (_, res) => res.json({ ok: true }));

app.use("/api/jobs", requireUser, jobsRouter);

const port = Number(process.env.PORT || 4000);
app.listen(port, () => console.log(`API running on ${port}`));




---

# 04-FRONTEND.md

```md
# Frontend (React Vite + TypeScript + shadcn/ui)

## Create project
From apps/web:

```bash
npm create vite@latest . -- --template react-ts
npm i
npm i @supabase/supabase-js react-router-dom
npm i clsx tailwind-merge
npm i lucide-react


import { createClient } from "@supabase/supabase-js";

export const supabase = createClient(
  import.meta.env.VITE_SUPABASE_URL!,
  import.meta.env.VITE_SUPABASE_ANON_KEY!
);


import { supabase } from "./supabase";

const base = import.meta.env.VITE_API_BASE_URL;

async function authHeader() {
  const { data } = await supabase.auth.getSession();
  const token = data.session?.access_token;
  return { Authorization: `Bearer ${token}` };
}

export async function apiPost(path: string, body: any) {
  const headers = await authHeader();
  const res = await fetch(`${base}${path}`, {
    method: "POST",
    headers: { "Content-Type": "application/json", ...headers },
    body: JSON.stringify(body)
  });
  return res.json();
}

export async function apiGet(path: string) {
  const headers = await authHeader();
  const res = await fetch(`${base}${path}`, { headers });
  return res.json();
}


await supabase.from("profiles").upsert({
  id: user.id,
  role,
  full_name,
  city
});


const result = await apiPost("/api/jobs", {
  care_type,
  children_count,
  children_age_group,
  location_city,
  start_at, // ISO string or omit
  shift_hours,
  languages_pref,
  requirements,
  budget_min,
  budget_max,
  notes,
  confirm_window_seconds: 90
});
navigate(`/client/jobs/${result.job_id}/confirmed`);




---

# 05-DEPLOY.md

```md
# Deployment MVP

## Supabase
- Create project
- Run db/sql files in order
- Enable Realtime on `messages` table in Supabase UI
- Add Auth redirect URLs for your domains

## Backend (Render / Railway)
- Deploy apps/api
- Set env:
  SUPABASE_URL
  SUPABASE_SERVICE_ROLE_KEY
  CORS_ORIGIN (your frontend URL)
  PORT

## Frontend (Vercel / Netlify)
- Deploy apps/web
- Env:
  VITE_SUPABASE_URL
  VITE_SUPABASE_ANON_KEY
  VITE_API_BASE_URL (your backend URL)

## Minimum security notes
- Do not expose service role key to frontend
- Keep all job orchestration endpoints in backend
- RLS policies protect user data on frontend queries

## Next upgrades (after MVP works)
- Geo radius matching (PostGIS or simple distance calc)
- Push notifications (FCM/APNs) with device_tokens table
- Payments (Stripe) with holds and capture on completion
- Dispute resolution and cancellation policies
- Anti-abuse: rate limit confirmations, prevent auto-click bots



````
